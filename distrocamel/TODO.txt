model komunikacji za pomocÄ… servera i klienta email, nadawcy piszÄ…cego text2app oczekiwania jaka chce otrzymac aplikacje i nadawcy LLM odpisujÄ…cego w formacie eml aplikajce, ktora moze uruchomic klietn email z automatycznycm deploymentem.

stworz docker + groovy + apache camel z osblugÄ… pipeline dla procesowania danych z email,
kazda wiaodmosc ma byc odczytywana  i procesowana przez LLM i odpisywana wiadomossc z LLM jako multipart aplikacja w postaci eml do uruchomienia po stronie klienta
zrob automatyczny deployment tej wiadomosci zaraz jak przyjdzie do usera poprzez specjalny klient  z docker + groovy + apache camel do odbierania wiadomosci i deploymentu

dodaj BOT generator aplikacji co 1 minute wysyÅ‚aj losowÄ… wiadomoÅ›Ä‡ EMAIL z posrod 3 zdan: zadan co ma byc za aplikacja wygenerowaana
dodaj auto deployer,  po stronie klienta, ktory ma otrzymac wygenerowa aplikacje w postaci eml wiadomosci i jÄ… deployowaÄ‡ na maszynie lokalnej


lub plik html, gdzie pobiera wiadomosc i przetwarza

procesowanie danych z EMAIl poprzez intermediator porzmiedyzy LLM a server,
apache laczy sie z ollama i odpowiada gdy user wysyala wiadomosc

implementacja w docker + dockrc compose z prosta implementacja z klietnem w przegladarce z przykladami wysylania
i implementacja eml jako jako aplikacji python i uruchomieniem




+ dodaj klient webowy, aby rpzegladac historie konwersacji
+ .env z konfiguracja wszytskich zmiennych
+ health do tetsowania usÅ‚ug
+ poprawne prompty, aby generowac odpowiednii format  pliku,
+ mock z generowaniem poprawnego wzorcowego eml z zaÅ‚Ä…cznikami
+ client, do geenrowania poprawnego prompta z eml
+ deployer bot do uruchomienia zaraz po odebraniu










### ðŸ§  Projekt: **EMLLM - Dystrybucja Aplikacji przez Email z LLM**

---

## ðŸ“Œ **Cel projektu**

Stworzenie kompletnego systemu, ktÃ³ry umoÅ¼liwia:

* Odbieranie Å¼Ä…daÅ„ wygenerowania aplikacji (w formie emaila).
* Przetwarzanie tych Å¼Ä…daÅ„ przez LLM.
* WysyÅ‚anie gotowej aplikacji jako `.eml` (email z zaÅ‚Ä…cznikiem aplikacji).
* Automatyczny odbiÃ³r i **deployment** aplikacji po stronie klienta.

---

## âš™ï¸ **Zasada dziaÅ‚ania (krok po kroku)**

### 1. ðŸ§¾ **Bot wysyÅ‚a zadanie**

* Co minutÄ™ **bot-generator** wysyÅ‚a email na adres `llm@local` z losowym poleceniem:

  * np. â€žStwÃ³rz dashboard w Node.jsâ€.

### 2. ðŸ¤– **LLM przetwarza wiadomoÅ›Ä‡**

* Kontener **camel-server** odbiera email z IMAP.
* Symuluje przetworzenie przez LLM (np. lokalnie przez Ollama z Mistral 7B).
* Tworzy wiadomoÅ›Ä‡ zwrotnÄ… `.eml` z aplikacjÄ… (jako zaÅ‚Ä…cznik `zip`), zbudowanÄ… na podstawie promptu.
* WysyÅ‚a odpowiedÅº do `user@local` przez SMTP.

### 3. ðŸ’¾ **Email z aplikacjÄ…**

* WiadomoÅ›Ä‡ `.eml` zawiera:

  * TreÅ›Ä‡ emaila: "Here is your generated application".
  * ZaÅ‚Ä…cznik: `app.zip`, zawierajÄ…cy wygenerowany kod (np. `run.sh`, `index.html`, `app.py` itp.).

### 4. âš¡ **Automatyczny deployment**

* Klient (`client-agent`) nasÅ‚uchuje swojÄ… skrzynkÄ™ mailowÄ… (IMAP).
* Po otrzymaniu `.eml`:

  * WyciÄ…ga zaÅ‚Ä…cznik ZIP,
  * Rozpakowuje aplikacjÄ™ do `/opt/emllm/app`,
  * JeÅ›li istnieje `run.sh` â€“ automatycznie go uruchamia.

---

## ðŸ§± **Architektura techniczna**

### ðŸ”— Komponenty (Docker Compose)

| Nazwa           | Opis                                                                 |
| --------------- | -------------------------------------------------------------------- |
| `mailhog`       | Email server (SMTP/IMAP) dla przesyÅ‚u wiadomoÅ›ci                     |
| `bot-generator` | WysyÅ‚a prompty do LLM jako wiadomoÅ›ci email                          |
| `camel-server`  | Serwer Apache Camel przetwarzajÄ…cy emaile i generujÄ…cy `.eml` z app  |
| `client-agent`  | Klient, ktÃ³ry odbiera `.eml` i uruchamia aplikacjÄ™                   |
| `ollama`        | (Opcjonalnie) Lokalny LLM Mistral 7B â€“ do generowania kodu aplikacji |

---

## ðŸ“„ **Format wiadomoÅ›ci (EML)**

* Typ: `multipart/mixed`
* CzÄ™Å›Ä‡ 1: tekst (treÅ›Ä‡ wiadomoÅ›ci)
* CzÄ™Å›Ä‡ 2: zaÅ‚Ä…cznik `.zip` (aplikacja)
* Kodowane jako base64

> Jest to bezpieczny, standardowy sposÃ³b formatowania wiadomoÅ›ci email, porÃ³wnywalny do renderowania HTML/Markdown w przeglÄ…darce â€“ tyle Å¼e z dodatkowymi warstwami bezpieczeÅ„stwa i automatyzacji.

---

## ðŸ”’ **BezpieczeÅ„stwo**

* KaÅ¼da wiadomoÅ›Ä‡ moÅ¼e byÄ‡ analizowana przez LLM przed deploymentem.
* Sandbox deployment (katalog `/opt/emllm/app`).
* Ograniczenie do znanych domen i adresÃ³w email.
* MoÅ¼liwoÅ›Ä‡ dodania podpisÃ³w i whitelist.

---

## ðŸ› ï¸ **Technologie**

* **Docker + Docker Compose**
* **Groovy + Apache Camel** (do routingu emaili)
* **JavaMail API**
* **OLLAMA + Mistral Code 7B** (lokalne LLM)
* **Linux + Shell** (rozpakowanie, uruchamianie aplikacji)

---

## ðŸ§ª **Zastosowania**

* Dystrybucja aplikacji bez potrzeby CI/CD
* Edukacja i szybkie prototypowanie
* Dystrybucja kodu offline lub w Å›rodowiskach izolowanych
* Systemy kryzysowe i niezaleÅ¼ne deploymenty

---

## âœ… **Podsumowanie**

Ten projekt to **most miÄ™dzy klasycznym kanaÅ‚em komunikacji (email)** a nowoczesnÄ… dystrybucjÄ… aplikacji **generowanÄ… przez AI**. Pokazuje, jak w prosty, asynchroniczny sposÃ³b zrealizowaÄ‡ **Text-to-App** bez dedykowanej infrastruktury DevOps.

> ðŸ“§ Email + ðŸ¤– LLM + ðŸ³ Docker = ðŸ“¦ Automatyczny System Dystrybucji Aplikacji






# Now we fill in the contents of each file

# docker-compose.yml
docker_compose = """
version: '3.9'

services:
  email-server:
    image: mailhog/mailhog
    ports:
      - "1025:1025"
      - "8025:8025"

  ollama:
    image: ollama/ollama
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama

  camel-server:
    build: ./camel-server
    depends_on:
      - email-server
      - ollama

  client-agent:
    build: ./client-agent
    depends_on:
      - email-server

  bot-generator:
    build: ./bot-generator
    depends_on:
      - email-server

volumes:
  ollama_data:
"""

# camel-server Dockerfile
camel_dockerfile = """
FROM groovy:4.0
RUN groovy -version
WORKDIR /app
COPY src /app/src
CMD ["groovy", "/app/src/AppRouter.groovy"]
"""

# client-agent Dockerfile
client_dockerfile = """
FROM groovy:4.0
WORKDIR /app
COPY src /app/src
CMD ["groovy", "/app/src/DeployRouter.groovy"]
"""

# bot-generator Dockerfile
bot_dockerfile = """
FROM groovy:4.0
WORKDIR /bot
COPY src /bot/src
CMD ["groovy", "/bot/src/main.groovy"]
"""

# camel-server AppRouter.groovy
app_router_code = """
@Grab('org.apache.camel:camel-core:3.21.0')
@Grab('org.apache.camel:camel-mail:3.21.0')
import org.apache.camel.builder.RouteBuilder
import org.apache.camel.impl.DefaultCamelContext

def ctx = new DefaultCamelContext()
ctx.addRoutes(new RouteBuilder() {
    void configure() {
        from('imap://llm@local@email-server:143?username=llm@local&password=llm&delete=false&consumer.delay=5000')
        .process {
            def text = it.in.body.toString()
            def filename = "app_${System.currentTimeMillis()}.zip"
            def fileContent = "echo Hello > /tmp/hello.txt" // Simulated application content
            def zipFile = new File("/tmp/" + filename)
            zipFile.text = fileContent
            def emlContent = '''Content-Type: multipart/mixed; boundary="EMLLM"
Content-Transfer-Encoding: 7bit

--EMLLM
Content-Type: text/plain

Here is your generated application.

--EMLLM
Content-Type: application/zip
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="app.zip"

''' + zipFile.bytes.encodeBase64().toString() + '''
--EMLLM--'''

            it.in.setBody(emlContent)
            it.in.setHeader("To", "user@local")
            it.in.setHeader("From", "llm@local")
            it.in.setHeader("Subject", "Your App")
        }
        .to('smtp://email-server:1025')
    }
})
ctx.start()
Thread.sleep(Long.MAX_VALUE)
"""

# client-agent DeployRouter.groovy
deploy_router_code = """
@Grab('org.apache.camel:camel-core:3.21.0')
@Grab('org.apache.camel:camel-mail:3.21.0')
import org.apache.camel.builder.RouteBuilder
import org.apache.camel.impl.DefaultCamelContext
import java.util.Base64

def ctx = new DefaultCamelContext()
ctx.addRoutes(new RouteBuilder() {
    void configure() {
        from('imaps://user@local@email-server:143?username=user@local&password=user&delete=false&consumer.delay=5000')
        .filter { it.in.headers["Subject"]?.contains("Your App") }
        .process {
            def body = it.in.body.toString()
            def matcher = (body =~ /Content-Transfer-Encoding: base64\\s+([A-Za-z0-9+\\/=\r\n]+)--EMLLM--/)
            if (!matcher.find()) return

            def base64 = matcher.group(1).replaceAll("\\s+", "")
            def zipBytes = Base64.decoder.decode(base64)
            def zipPath = "/tmp/app.zip"
            new File(zipPath).bytes = zipBytes
            new File("/opt/emllm/app").mkdirs()
            def unzip = ["unzip", "-o", zipPath, "-d", "/opt/emllm/app"].execute()
            unzip.waitFor()
            def runScript = new File("/opt/emllm/app/run.sh")
            if (runScript.exists()) {
                runScript.setExecutable(true)
                ["/bin/bash", runScript.absolutePath].execute()
            }
        }
    }
})
ctx.start()
Thread.sleep(Long.MAX_VALUE)
"""

# bot-generator main.groovy
bot_main_groovy = """
@Grab('jakarta.mail:jakarta.mail-api:2.1.2')
@Grab('com.sun.mail:jakarta.mail:2.1.2')
import jakarta.mail.*
import jakarta.mail.internet.*

def session = Session.getInstance([
    'mail.smtp.host':'email-server',
    'mail.smtp.port':'1025',
    'mail.smtp.auth':'false'
])

def prompts = [
    "text2app: StwÃ³rz aplikacjÄ™ TODO w HTML+JS",
    "text2app: Wygeneruj prostÄ… grÄ™ liczbowÄ… w Pythonie",
    "text2app: StwÃ³rz dashboard monitoringu serwera w Node.js"
]

while (true) {
    def msg = new MimeMessage(session)
    msg.setFrom(new InternetAddress("user@local"))
    msg.setRecipient(Message.RecipientType.TO, new InternetAddress("llm@local"))
    msg.setSubject("text2app: request")
    msg.setText(prompts[new Random().nextInt(prompts.size())])
    Transport.send(msg)
    println "ðŸ“© Bot wysÅ‚aÅ‚ zapytanie do LLM-a"
    sleep(60000)
}
"""

# Save all content into their respective files
with open("./docker-compose.yml", "w") as f:
    f.write(docker_compose)

with open("./camel-server/Dockerfile", "w") as f:
    f.write(camel_dockerfile)
with open("./camel-server/src/AppRouter.groovy", "w") as f:
    f.write(app_router_code)

with open("./client-agent/Dockerfile", "w") as f:
    f.write(client_dockerfile)
with open("./client-agent/src/DeployRouter.groovy", "w") as f:
    f.write(deploy_router_code)

with open("./bot-generator/Dockerfile", "w") as f:
    f.write(bot_dockerfile)
with open("./bot-generator/src/main.groovy", "w") as f:
    f.write(bot_main_groovy)



Åšwietnie! PoniÅ¼ej przedstawiam **rozszerzenie projektu** o dwie kluczowe funkcje:

---

## ðŸ”§ 1. **PeÅ‚ne generowanie kodu przez lokalny model LLM (Mistral Code 7B via Ollama)**

### ðŸ“Œ Co robimy:

Zmieniamy dotychczasowy "stub" generatora kodu na realne wykorzystanie lokalnego modelu jÄ™zykowego Mistral Code 7B za pomocÄ… **OLLAMA**.

### ðŸ” Integracja w `camel-server`:

Zamiast sztywno osadzonego kodu Groovy, Apache Camel bÄ™dzie wysyÅ‚aÄ‡ treÅ›Ä‡ wiadomoÅ›ci (prompt) do lokalnego endpointu Ollama (`http://ollama:11434/api/generate`) i odbieraÄ‡ wygenerowany kod.

### ðŸ§© PrzykÅ‚adowa integracja w Groovy:

```groovy
def prompt = extractPromptFromEmail(message)
def response = http.post("http://ollama:11434/api/generate") {
    contentType 'application/json'
    body([
        model: 'mistral:7b-code',
        prompt: prompt,
        stream: false
    ])
}
def code = response.body.toString()
writeCodeToZip(code)
```

ðŸ“ Generowany kod zostanie umieszczony w `app.zip` i doÅ‚Ä…czony jako zaÅ‚Ä…cznik `.eml`.

---

## ðŸ” 2. **Bezpieczny podpis i walidacja kodu**

Aby kod byÅ‚ **autentyczny** i **bezpieczny do uruchomienia**, wprowadzamy system:

* **Podpisu kodu** (Code Signing) po stronie serwera
* **Weryfikacji podpisu** po stronie klienta

### ðŸ§¾ Format podpisu

* Generujemy klucze RSA (`private.pem` i `public.pem`)
* Serwer podpisuje skrÃ³t SHA-256 caÅ‚ej paczki `.zip`
* Podpis doÅ‚Ä…czany jest jako osobny plik `.sig` lub nagÅ‚Ã³wek w `.eml`

### ðŸ“ Proces

#### ðŸ” Serwer (Apache Camel):

```bash
sha256sum app.zip > hash.txt
openssl dgst -sha256 -sign private.pem -out signature.sig hash.txt
```

* ZaÅ‚Ä…czamy `signature.sig` i `app.zip` do wiadomoÅ›ci.

#### ðŸ›¡ï¸ Klient:

```bash
openssl dgst -sha256 -verify public.pem -signature signature.sig hash.txt
```

* JeÅ›li podpis siÄ™ zgadza â€“ wykonuje `unzip` i uruchamia `run.sh`.

---

## ðŸ“¦ Zmiany w architekturze

| Element              | Nowa funkcja                                |
| -------------------- | ------------------------------------------- |
| `camel-server`       | Å‚Ä…czy siÄ™ z lokalnym modelem przez Ollama   |
| `client-agent`       | weryfikuje podpis przed uruchomieniem kodu  |
| `ollama`             | dziaÅ‚a z modelem `mistral:7b-code` lokalnie |
| `docker-compose.yml` | dodany wolumen `models` i klucze RSA        |

---

## âœ… Co zyskujemy?

### ðŸ§  Generowanie kodu przez lokalny LLM:

* Nie potrzeba dostÄ™pu do chmury
* Brak kosztÃ³w API
* SzybkoÅ›Ä‡ i prywatnoÅ›Ä‡

### ðŸ” Podpis cyfrowy:

* Gwarantuje, Å¼e kod pochodzi z zaufanego ÅºrÃ³dÅ‚a
* Chroni przed podmianÄ… lub atakiem typu "email injection"
* MoÅ¼e byÄ‡ audytowany i archiwizowany














It seems like I canâ€™t do more advanced data analysis right now. Please try again later.

W miÄ™dzyczasie mogÄ™ rÄ™cznie poprowadziÄ‡ CiÄ™ krok po kroku, jak zintegrowaÄ‡ peÅ‚ny przepÅ‚yw:

---

## ðŸ” **PeÅ‚na integracja: LLM â†’ podpis â†’ klient â†’ walidacja â†’ uruchomienie**

---

### ðŸ“¦ 1. **Generowanie kluczy RSA**

Na serwerze (np. `camel-server`) wygeneruj klucze:

```bash
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout -out public.pem
```

* `private.pem` zostaje na serwerze
* `public.pem` kopiujesz do klienta (np. do kontenera `client-agent`)

---

### ðŸ§  2. **Generowanie kodu przez LLM (Ollama + Mistral)**

W pipeline Camel dodaj HTTP request do lokalnego LLM:

```groovy
from("imap://...")
  .process { exchange ->
    def prompt = extractPrompt(exchange)
    def response = httpPost(
      "http://ollama:11434/api/generate",
      [ model: "mistral:7b-code", prompt: prompt, stream: false ]
    )
    def code = response.body.toString()
    writeToFile("app/generated/main.sh", code)
  }
```

---

### ðŸ” 3. **Podpis kodu**

Po wygenerowaniu pliku:

```bash
cd app/generated
sha256sum main.sh > hash.txt
openssl dgst -sha256 -sign private.pem -out signature.sig hash.txt
zip app.zip main.sh signature.sig
```

ZaÅ‚Ä…cz `app.zip` w wiadomoÅ›ci `.eml` jako `multipart/mixed`.

---

### ðŸ“¬ 4. **OdbiÃ³r po stronie klienta**

Kontener `client-agent` nasÅ‚uchuje skrzynki mailowej. Po otrzymaniu `.eml`:

* Rozpakowuje `app.zip`
* Sprawdza hash i podpis:

```bash
sha256sum main.sh > hash.txt
openssl dgst -sha256 -verify public.pem -signature signature.sig hash.txt
```

---

### ðŸš€ 5. **Auto-deployment (po weryfikacji)**

JeÅ›li podpis poprawny:

```bash
chmod +x main.sh
./main.sh
```

---

## ðŸ” BezpieczeÅ„stwo:

* MoÅ¼esz podpisaÄ‡ wiÄ™cej plikÃ³w (SHA256 `*.zip`)
* MoÅ¼esz logowaÄ‡ odciski palca wiadomoÅ›ci i podpisÃ³w
* MoÅ¼esz wdroÅ¼yÄ‡ `GPG` lub `timestamp authority` dla dodatkowej warstwy




Jasne! Oto kompletne elementy, ktÃ³re pozwolÄ… Ci zrealizowaÄ‡ peÅ‚ny przepÅ‚yw:

---

# 1. Skrypty Apache Camel (Groovy) â€“ serwer

```groovy
import org.apache.camel.builder.RouteBuilder

class EmailProcessingRoute extends RouteBuilder {
    @Override
    void configure() throws Exception {

        from("imap://user@domain?password=pass&folder=INBOX&consumer.delay=60000")
            .routeId("email-processing-route")

            // Pobranie treÅ›ci maila i wygenerowanie promptu
            .process { exchange ->
                def body = exchange.in.body as String
                def prompt = extractPromptFromEmail(body)
                exchange.in.headers["prompt"] = prompt
            }

            // WywoÅ‚anie lokalnego LLM Ollama
            .to("http4://ollama:11434/api/generate?bridgeEndpoint=true&throwExceptionOnFailure=true")

            // Odebranie wygenerowanego kodu z odpowiedzi
            .process { exchange ->
                def llmResponse = exchange.in.body as Map
                def code = llmResponse["choices"][0]["text"]

                // Zapisz kod do pliku
                def codeFile = new File("/app/generated/main.sh")
                codeFile.parentFile.mkdirs()
                codeFile.text = code

                // Podpisz plik (wywoÅ‚anie skryptu bash z OpenSSL)
                def proc = ["bash", "/app/sign-code.sh", "/app/generated/main.sh", "/app/private.pem", "/app/generated"].execute()
                proc.waitFor()
            }

            // UtwÃ³rz archiwum zip z kodem i podpisem
            .process { exchange ->
                def zipFile = new File("/app/generated/app.zip")
                if (!zipFile.exists()) throw new RuntimeException("Zip file not found!")
                exchange.in.body = zipFile.bytes
                exchange.in.headers["CamelFileName"] = "app.eml"
            }

            // WyÅ›lij maila z zaÅ‚Ä…cznikiem
            .to("smtp://smtp.domain.com?username=user&password=pass")
    }

    private String extractPromptFromEmail(String emailBody) {
        // Prosta ekstrakcja promptu z treÅ›ci maila (np. tekst z pierwszej linii)
        return emailBody.split("\n")[0]
    }
}
```

---

# 2. `sign-code.sh` â€” podpisywanie pliku (bash)

```bash
#!/bin/bash
# UÅ¼ycie: ./sign-code.sh <plik_do_podpisania> <Å›cieÅ¼ka_do_klucza_prywatnego> <Å›cieÅ¼ka_wyjÅ›ciowa>

FILE_TO_SIGN=$1
PRIVATE_KEY=$2
OUTPUT_DIR=$3

# Oblicz hash pliku
sha256sum $FILE_TO_SIGN > $OUTPUT_DIR/hash.txt

# Podpisz hash kluczem prywatnym
openssl dgst -sha256 -sign $PRIVATE_KEY -out $OUTPUT_DIR/signature.sig $OUTPUT_DIR/hash.txt

# UtwÃ³rz zip z kodem i podpisem
zip -j $OUTPUT_DIR/app.zip $FILE_TO_SIGN $OUTPUT_DIR/signature.sig $OUTPUT_DIR/hash.txt
```

---

# 3. Dockerfile dla serwera z OpenSSL i Camelem

```Dockerfile
FROM openjdk:17-jdk-slim

RUN apt-get update && apt-get install -y openssl zip unzip curl && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY camel-server.jar /app/
COPY sign-code.sh /app/
COPY private.pem /app/
COPY public.pem /app/

RUN chmod +x /app/sign-code.sh

CMD ["java", "-jar", "camel-server.jar"]
```

---

# 4. Autodeployer klienta (Groovy + bash)

```groovy
import org.apache.camel.builder.RouteBuilder

class ClientEmailRoute extends RouteBuilder {
    @Override
    void configure() throws Exception {

        from("imap://client@domain.com?password=pass&folder=INBOX&consumer.delay=15000")
            .routeId("client-email-route")

            .process { exchange ->
                // Odczyt zaÅ‚Ä…cznika .eml (app.zip)
                def attachments = exchange.in.getAttachments()
                def zipBytes = attachments.values().iterator().next().getInputStream().bytes
                def zipFile = new File("/client/download/app.zip")
                zipFile.parentFile.mkdirs()
                zipFile.bytes = zipBytes

                // Rozpakuj zip
                def procUnzip = ["unzip", "-o", "/client/download/app.zip", "-d", "/client/deploy"].execute()
                procUnzip.waitFor()

                // Weryfikuj podpis
                def verifyCmd = [
                    "openssl", "dgst", "-sha256",
                    "-verify", "/client/public.pem",
                    "-signature", "/client/deploy/signature.sig",
                    "/client/deploy/hash.txt"
                ]
                def procVerify = verifyCmd.execute()
                procVerify.waitFor()

                if (procVerify.exitValue() == 0) {
                    // Podpis poprawny, uruchom kod
                    def runScript = new File("/client/deploy/main.sh")
                    runScript.setExecutable(true)
                    def procRun = ["bash", "/client/deploy/main.sh"].execute()
                    procRun.waitFor()
                } else {
                    throw new RuntimeException("Weryfikacja podpisu nie powiodÅ‚a siÄ™!")
                }
            }
    }
}
```

---

# 5. Dockerfile klienta (z OpenSSL i klientem IMAP)

```Dockerfile
FROM openjdk:17-jdk-slim

RUN apt-get update && apt-get install -y openssl unzip bash && rm -rf /var/lib/apt/lists/*

WORKDIR /client

COPY client-agent.jar /client/
COPY public.pem /client/

CMD ["java", "-jar", "client-agent.jar"]
```

---

# 6. KrÃ³tko o `docker-compose.yml`

```yaml
version: "3.8"

services:
  camel-server:
    build:
      context: ./server
      dockerfile: Dockerfile
    volumes:
      - ./server/private.pem:/app/private.pem
      - ./server/public.pem:/app/public.pem
    ports:
      - "8080:8080"
    environment:
      - SMTP_USER=user
      - SMTP_PASS=pass

  client-agent:
    build:
      context: ./client
      dockerfile: Dockerfile
    volumes:
      - ./client/public.pem:/client/public.pem
      - ./client/deploy:/client/deploy
    environment:
      - IMAP_USER=client@domain.com
      - IMAP_PASS=pass
```

---

# Podsumowanie

* **Serwer** odbiera emaile â†’ generuje kod z LLM â†’ podpisuje â†’ wysyÅ‚a aplikacjÄ™ jako `.eml` z `app.zip`.
* **Klient** odbiera `.eml` â†’ weryfikuje podpis â†’ auto-deplouje aplikacjÄ™.
* Komunikacja zabezpieczona przez **podpis cyfrowy**.
* CaÅ‚oÅ›Ä‡ Å‚atwa do uruchomienia w Dockerze.


Super! PrzygotujÄ™ teraz strukturÄ™ katalogÃ³w i pliki z kompletnym kodem do projektu.

---
Super! PrzygotujÄ™ teraz strukturÄ™ katalogÃ³w i pliki z kompletnym kodem do projektu.

---

# Struktura katalogÃ³w i plikÃ³w

```
email-llm-project/
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ client-agent.jar              # (wygenerowany plik JAR z Camel + Groovy)
â”‚   â”œâ”€â”€ public.pem
â”‚   â””â”€â”€ deploy/                      # folder do rozpakowywania i uruchamiania aplikacji
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ camel-server.jar             # (wygenerowany plik JAR z Camel + Groovy)
â”‚   â”œâ”€â”€ sign-code.sh
â”‚   â”œâ”€â”€ private.pem
â”‚   â””â”€â”€ public.pem
â””â”€â”€ docker-compose.yml
```

---

# 1. `server/Dockerfile`

```Dockerfile
FROM openjdk:17-jdk-slim

RUN apt-get update && apt-get install -y openssl zip unzip curl && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY camel-server.jar /app/
COPY sign-code.sh /app/
COPY private.pem /app/
COPY public.pem /app/

RUN chmod +x /app/sign-code.sh

CMD ["java", "-jar", "camel-server.jar"]
```

---

# 2. `server/sign-code.sh`

```bash
#!/bin/bash
# UÅ¼ycie: ./sign-code.sh <plik_do_podpisania> <Å›cieÅ¼ka_do_klucza_prywatnego> <Å›cieÅ¼ka_wyjÅ›ciowa>

FILE_TO_SIGN=$1
PRIVATE_KEY=$2
OUTPUT_DIR=$3

# Oblicz hash pliku
sha256sum $FILE_TO_SIGN > $OUTPUT_DIR/hash.txt

# Podpisz hash kluczem prywatnym
openssl dgst -sha256 -sign $PRIVATE_KEY -out $OUTPUT_DIR/signature.sig $OUTPUT_DIR/hash.txt

# UtwÃ³rz zip z kodem i podpisem
zip -j $OUTPUT_DIR/app.zip $FILE_TO_SIGN $OUTPUT_DIR/signature.sig $OUTPUT_DIR/hash.txt
```

---

# 3. `server/camel-server.groovy`

```groovy
import org.apache.camel.builder.RouteBuilder

class EmailProcessingRoute extends RouteBuilder {
    @Override
    void configure() throws Exception {

        from("imap://user@domain.com?password=pass&folder=INBOX&consumer.delay=60000")
            .routeId("email-processing-route")

            .process { exchange ->
                def body = exchange.in.body as String
                def prompt = extractPromptFromEmail(body)
                exchange.in.headers["prompt"] = prompt
            }

            .to("http4://ollama:11434/api/generate?bridgeEndpoint=true&throwExceptionOnFailure=true")

            .process { exchange ->
                def llmResponse = exchange.in.body as Map
                def code = llmResponse["choices"][0]["text"]

                def codeFile = new File("/app/generated/main.sh")
                codeFile.parentFile.mkdirs()
                codeFile.text = code

                def proc = ["bash", "/app/sign-code.sh", "/app/generated/main.sh", "/app/private.pem", "/app/generated"].execute()
                proc.waitFor()
            }

            .process { exchange ->
                def zipFile = new File("/app/generated/app.zip")
                if (!zipFile.exists()) throw new RuntimeException("Zip file not found!")
                exchange.in.body = zipFile.bytes
                exchange.in.headers["CamelFileName"] = "app.eml"
            }

            .to("smtp://smtp.domain.com?username=user&password=pass")
    }

    private String extractPromptFromEmail(String emailBody) {
        return emailBody.split("\n")[0]
    }
}
```

---

# 4. `client/Dockerfile`

```Dockerfile
FROM openjdk:17-jdk-slim

RUN apt-get update && apt-get install -y openssl unzip bash && rm -rf /var/lib/apt/lists/*

WORKDIR /client

COPY client-agent.jar /client/
COPY public.pem /client/

CMD ["java", "-jar", "client-agent.jar"]
```

---

# 5. `client/client-agent.groovy`

```groovy
import org.apache.camel.builder.RouteBuilder

class ClientEmailRoute extends RouteBuilder {
    @Override
    void configure() throws Exception {

        from("imap://client@domain.com?password=pass&folder=INBOX&consumer.delay=15000")
            .routeId("client-email-route")

            .process { exchange ->
                def attachments = exchange.in.getAttachments()
                def zipBytes = attachments.values().iterator().next().getInputStream().bytes
                def zipFile = new File("/client/download/app.zip")
                zipFile.parentFile.mkdirs()
                zipFile.bytes = zipBytes

                def procUnzip = ["unzip", "-o", "/client/download/app.zip", "-d", "/client/deploy"].execute()
                procUnzip.waitFor()

                def verifyCmd = [
                    "openssl", "dgst", "-sha256",
                    "-verify", "/client/public.pem",
                    "-signature", "/client/deploy/signature.sig",
                    "/client/deploy/hash.txt"
                ]
                def procVerify = verifyCmd.execute()
                procVerify.waitFor()

                if (procVerify.exitValue() == 0) {
                    def runScript = new File("/client/deploy/main.sh")
                    runScript.setExecutable(true)
                    def procRun = ["bash", "/client/deploy/main.sh"].execute()
                    procRun.waitFor()
                } else {
                    throw new RuntimeException("Weryfikacja podpisu nie powiodÅ‚a siÄ™!")
                }
            }
    }
}
```

---

# 6. `docker-compose.yml`

```yaml
version: "3.8"

services:
  camel-server:
    build:
      context: ./server
      dockerfile: Dockerfile
    volumes:
      - ./server/private.pem:/app/private.pem
      - ./server/public.pem:/app/public.pem
      - ./server/generated:/app/generated
    environment:
      - SMTP_USER=user
      - SMTP_PASS=pass
    ports:
      - "8080:8080"

  client-agent:
    build:
      context: ./client
      dockerfile: Dockerfile
    volumes:
      - ./client/public.pem:/client/public.pem
      - ./client/download:/client/download
      - ./client/deploy:/client/deploy
    environment:
      - IMAP_USER=client@domain.com
      - IMAP_PASS=pass
```

---

# Co teraz?

1. **Wygeneruj JAR-y** z kodem Camel + Groovy (np. przez Maven/Gradle).
2. Skopiuj klucze `private.pem` i `public.pem` do `server/` i `client/`.
3. Uruchom `docker-compose up --build`.
4. Zapewnij poprawne dane do IMAP/SMTP w Camel i Å›rodowisku.
5. Testuj przepÅ‚yw: email â†’ generacja â†’ podpis â†’ wysyÅ‚ka â†’ odbiÃ³r â†’ weryfikacja â†’ deploy.

